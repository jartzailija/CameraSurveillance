/**
* Idea got from http://www.pyimagesearch.com/2015/06/01/home-surveillance-and-motion-detection-with-the-raspberry-pi-python-and-opencv/
* TODO: make node.js -addon: https://nodejs.org/api/addons.html
*
* Uses C++11 -standard
*/

#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <iostream>
#include <chrono>
#include <unistd.h>
#include <raspicam/raspicam_cv.h>

using namespace cv;
using namespace std;

// Global variables
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
bool firstFrameEncountered;
raspicam::RaspiCam_Cv Camera;
int normalSleepTime, filmingSleepTime;
int recordTime = 5;
bool motionDetected;


void guard();
void compare();
void saveImage();
void shootFilm();
Mat shootImage();
unsigned long getEpochTime();

int main(int argc, char* argv[])
{
	firstFrameEncountered = false;
	motionDetected = false;
	
	//Pause for half second between images at the guard mode
	normalSleepTime = 500000;
	
	//25 fps
	filmingSleepTime = 40000;
	
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	
	if (!Camera.open()) {
		cerr << "Error opening the camera" << endl;
		return -1;
	}
	
	guard();
	
	Camera.release();
   
    return EXIT_SUCCESS;
}

void guard() {
	
	//Ensure, that it is a normal mode
	firstFrameEncountered = false;
    
    while(true){
		
		compare();
		usleep(normalSleepTime);

    }
}

void shootFilm() {
	int frameCount = 0;
	unsigned long startingTime = getEpochTime();
	while(true){
		
		if(frameCount % 10 == 0) {
			compare();
		}
		saveImage();
		frameCount++
		usleep(filmingSleepTime);
		
		if(getEpochTime() - filmingSleepTime >= recordTime) {
			//TODO: tapa t채m채 aliprosessi
		}
    }
}

void toggle() {
	if(!motionDetected) {
		guard();
	}
	else {
		shootFilm();
	}
	motionDetected = !motionDetected;
	
}

void compare() {
	Mat frame = shootImage();
	Mat blurFrame;
	
	//Turn the image to gray
	cvtColor(frame, blurFrame, CV_BGR2GRAY );
	
	//Blur it
	GaussianBlur( blurFrame, blurFrame, Size( 21, 21 ), 0, 0 );
	
	//update the background model and set a comparsion image
	//comparsion image will be black, except if there was differences
	//between images. Then diffs are gray
	pMOG2->apply(blurFrame, fgMaskMOG2);
	
	
	//The first frame must be skipped, or it will cause a false alarm
	if(!firstFrameEncountered) {
		firstFrameEncountered = true;
	}
	
	else {
	
		//Gray to white
		threshold(fgMaskMOG2, blurFrame, 5.0d, 255, THRESH_BINARY);
				
		Mat element = getStructuringElement( MORPH_RECT,
			Size( 21, 21 ),
			Point( 10, 10 ) );
		
		//Bold white areas
		dilate(blurFrame, blurFrame, element, Point( -1, -1 ), 2);
			
		vector<vector<Point>> contours;
		
		//Check, if shapes are bigger than the limit value
		findContours(blurFrame, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE );
		
		for (int i = 0; i < contours.size(); i++){
			
			//Movement detected
			if(contourArea(contours[i]) > 15000) {
				
				cout << "Motion detected." << endl;
				//TODO: tapa t채m채 aliprosessi				
			}
		}
	}
}

unsigned long getEpochTime() {
	using namespace std::chrono;
	auto now = system_clock::now();
	auto now_s = time_point_cast<seconds>(now);

	auto value = now_s.time_since_epoch();
	unsigned long duration = value.count();
	return duration;
}

void saveImage(frame) {
	
	auto now = std::chrono::system_clock::now();
	auto now_ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);

	auto value = now_ms.time_since_epoch();
	unsigned long duration = value.count();
	
	string name = to_string(duration) + ".jpg";
	imwrite(name, frame);
	cout << name << endl;
	
	/* TODO: send binary to stdout or something
	vector<uchar> buf(50000);
	imencode(".jpg", frame, buf);
	*/
}

Mat shootImage() {
	Mat img;
	
	Camera.grab();
	Camera.retrieve(img);
	
	return img;
}
